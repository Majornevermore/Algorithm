package main

import "sort"

//ç»™å‡ºä¸€ä¸ªåŒºé—´çš„é›†åˆï¼Œè¯·åˆå¹¶æ‰€æœ‰é‡å çš„åŒºé—´ã€‚
//
//
//
// ç¤ºä¾‹ 1:
//
// è¾“å…¥: intervals = [[1,3],[2,6],[8,10],[15,18]]
//è¾“å‡º: [[1,6],[8,10],[15,18]]
//è§£é‡Š: åŒºé—´ [1,3] å’Œ [2,6] é‡å , å°†å®ƒä»¬åˆå¹¶ä¸º [1,6].
//
//
// ç¤ºä¾‹ 2:
//
// è¾“å…¥: intervals = [[1,4],[4,5]]
//è¾“å‡º: [[1,5]]
//è§£é‡Š: åŒºé—´ [1,4] å’Œ [4,5] å¯è¢«è§†ä¸ºé‡å åŒºé—´ã€‚
//
// æ³¨æ„ï¼šè¾“å…¥ç±»å‹å·²äº2019å¹´4æœˆ15æ—¥æ›´æ”¹ã€‚ è¯·é‡ç½®é»˜è®¤ä»£ç å®šä¹‰ä»¥è·å–æ–°æ–¹æ³•ç­¾åã€‚
//
//
//
// æç¤ºï¼š
//
//
// intervals[i][0] <= intervals[i][1]
//
// Related Topics æ’åº æ•°ç»„
// ğŸ‘ 727 ğŸ‘ 0

//leetcode submit region begin(Prohibit modification and deletion)
func merge1(intervals [][]int) [][]int {
	if len(intervals) == 0 {
		return nil
	}
	sort.Slice(intervals, func(i, j int) bool {
		if intervals[i][0] != intervals[j][0] {
			return intervals[i][0] < intervals[j][0]
		}
		return intervals[i][1] > intervals[j][1]
	})
	var res [][]int
	res = append(res, intervals[0])
	for i := 1; i < len(intervals); i++ {
		cur := intervals[i]
		if cur[0] <= res[len(res)-1][1] {
			res[len(res)-1][1] = maxMerge(res[len(res)-1][1], cur[1])
		} else {
			res = append(res, cur)
		}
	}
	return res
}

func maxMerge(x, y int) int {
	if x < y {
		return y
	}
	return x
}

//leetcode submit region end(Prohibit modification and deletion)

func main() {
}
